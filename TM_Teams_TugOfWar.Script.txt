/**
 *	TM_Teams_Online mode
 */
#Extends "Modes/Nadeo/Trackmania/Base/TrackmaniaRoundsBase.Script.txt"

#Const	CompatibleMapTypes	"TrackMania\\TM_Race,TM_Race"
#Const	Version							"2025-05-18"
#Const	ScriptName					"Modes/TrackMania/TM_Teams_TugOfWar.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// MARK: Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/CMGame/Utils/Semver.Script.txt" as Semver
#Include "Libs/Nadeo/Trackmania/Modes/Teams/StateManager.Script.txt" as StateMgr
#Include "Libs/Nadeo/Trackmania/MainMenu/Constants.Script.txt" as MenuConsts
#Include "Libs/Nadeo/TMGame/Utils/Tracking.Script.txt" as Tracking
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/Checkpoint_Server.Script.txt" as UIModules_Checkpoint
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/PauseMenuOnline_Server.Script.txt" as UIModules_PauseMenu_Online
#Include "Libs/Nadeo/TMGame/Modes/Teams/TeamsCommon.Script.txt" as TeamsCommonLib

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// MARK: Settings
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Setting S_FinishTimeout 15 as _("Finish timeout")
#Setting S_RoundsPerMap -1 as _("Number of rounds per track :") ///< Number of round to play on one map before going to the next one
#Setting S_MapsPerMatch 1 as _("Number of tracks per match :") ///< Number of maps to play before finishing the matchn
#Setting S_WarmUpNb 1 as _("Number of warm up :")
#Setting S_WarmUpDuration 0 as _("Duration of one warm up :")
#Setting S_WarmUpTimeout -1 as _("Warm up timeout")
#Setting S_MaxTimeDelta 5.0 as _("Max limit for time delta to go either way, like a point limit in Cup mode")
#Setting S_MaxRoundDelta 5.0 as _("Max swing that can happen in a single round")
#Setting S_MaxRounds -1 as _("Max rounds that can occur on a single map, -1 or 0 means infinite")


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// MARK: Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_ModeName "TM_Teams_TugOfWar"

#Const C_HudModulePath "" //< Path to the hud module
#Const C_ManiaAppUrl "file://Media/ManiaApps/Nadeo/Trackmania/Modes/Teams.Script.txt" //< Url of the mania app

#Const C_BlueBotsNb 0
#Const C_RedBotsNb 0

#Const C_UploadRecord True
#Const C_DisplayRecordGhost False
#Const C_DisplayRecordMedal False
#Const C_CelebrateRecordGhost False
#Const C_CelebrateRecordMedal False

#Const C_MlId_LiveRanking "Tig.LiveRanking"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// MARK: Extends
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
***Match_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
Log::RegisterScript(Semver::ScriptName, Semver::Version);
Log::RegisterScript(ModeUtils::ScriptName, ModeUtils::Version);
Log::RegisterScript(StateMgr::ScriptName, StateMgr::Version);
***

***Match_LoadLibraries***
***
StateMgr::Load();
***

***Match_UnloadLibraries***
***
StateMgr::Unload();
***

***Match_Settings***
***
MB_Settings_UseDefaultHud = (C_HudModulePath == "");
***

***Match_Rules***
***
ModeInfo::SetName(C_ModeName);
ModeInfo::SetType(ModeInfo::C_Type_Teams);
ModeInfo::SetStatusMessage("");
***

***Match_LoadHud***
***
if (C_HudModulePath != "") Hud_Load(C_HudModulePath);
***

***Match_AfterLoadHud***
***
ClientManiaAppUrl = C_ManiaAppUrl;
Race::SortScores(Race::C_Sort_BestRaceTime);
UIModules_Checkpoint::SetVisibilityTimeDiff(False);
UIModules_Checkpoint::SetRankMode(UIModules_Checkpoint::C_RankMode_CurrentRace);
UIModules_Sign16x9Small::SetScoreMode(UIModules_Sign16x9Small::C_ScoreMode_Points);
// Hide SM Overlay
UIManager.UIAll.OverlayHideSpectatorInfos = True;
UIManager.UIAll.OverlayHideCountdown = True;
LoadUI();
***

***Match_Yield***
***
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		// Initialize players when they join the server
		case CSmModeEvent::EType::OnPlayerAdded: {
			StateMgr::InitializePlayer(Event.Player);
			CarRank::InitializePlayer(Event.Player);
		}
	}
}

StateMgr::Yield();
***

***Match_InitServer***
***
declare Integer Server_RoundsPerMap;
declare Integer Server_MapsPerMatch;

declare Integer Team1_MapWins = 0;
declare Integer Team2_MapWins = 0;

declare Integer LatestDeltaVersion = 0;

declare Integer Match_MapsCount;

***

***Match_StartServer***
***
// Initialize mode
Clans::SetClansNb(2);
Scores::SaveInScore(Scores::C_Points_Match);
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
WarmUp::SetAvailability(True);
Race::SetupRecord(
	MenuConsts::C_ScopeType_Season,
	MenuConsts::C_ScopeType_PersonalBest,
	MenuConsts::C_GameMode_TimeAttack,
	"",
	C_UploadRecord,
	C_DisplayRecordGhost,
	C_DisplayRecordMedal,
	C_CelebrateRecordGhost,
	C_CelebrateRecordMedal
);
Server_RoundsPerMap = S_RoundsPerMap - 1;
Server_MapsPerMatch = S_MapsPerMatch - 1;
***

***Match_StartMatch***
***

Team1_MapWins = 0;
Team2_MapWins = 0;

LatestDeltaVersion = 0;

Match_MapsCount = 0;

declare netwrite Integer RedMapWins for Teams[0];
RedMapWins = Team2_MapWins;
declare netwrite Integer BlueMapWins for Teams[0];
BlueMapWins = Team1_MapWins;


***

***Match_InitMap***
***
UIModules_ScoresTable::SetScoreMode(UIModules_ScoresTable::C_Mode_PrevTime);
UIModules_ScoresTable::DisplayRoundPoints(True);

// Restore match points
Scores::SetClanMapPoints(1, Scores::GetClanMatchPoints(1));
Scores::SetClanMapPoints(2, Scores::GetClanMatchPoints(2));

declare Integer Map_ValidRoundsNb;

declare Real Map_TimeDelta = 0.0;
***

***Match_StartMap***
***

CarRank::Reset();

Match_MapsCount += 1;

UIModules_ScoresTable::SetInfoMessage(_("Warm up"));
MB_WarmUp(S_WarmUpNb, S_WarmUpDuration * 1000, S_WarmUpTimeout * 1000);

declare Text MaxRoundsText = S_MaxRounds ^ "";

if (S_MaxRounds <= 0) {
	MaxRoundsText = "Unlimited";
}

UIModules_ScoresTable::SetFooterInfo(TL::Compose("Round " ^ (Map_ValidRoundsNb + 1) ^ " / " ^ MaxRoundsText ^ " Map " ^ Match_MapsCount ^ " / " ^ S_MapsPerMatch));
UIModules_ScoresTable::SetInfoMessage(TL::Compose("\n\nMax Time Delta: " ^ S_MaxTimeDelta ^ "  "));
***

***Match_StartRound***
***

declare Text MaxRoundsText = S_MaxRounds ^ "";

if (S_MaxRounds <= 0) {
	MaxRoundsText = "Unlimited";
}


UIModules_ScoresTable::SetFooterInfo(TL::Compose("Round " ^ (Map_ValidRoundsNb + 1) ^ " / " ^ MaxRoundsText ^ " Map " ^ Match_MapsCount ^ " / " ^ S_MapsPerMatch));
UIModules_ScoresTable::SetInfoMessage(TL::Compose("\n\nMax Time Delta: " ^ S_MaxTimeDelta ^ "  "));

StateMgr::ForcePlayersStates([StateMgr::C_State_Playing]);
***

***Rounds_PlayerSpawned***
***
CarRank::ThrottleUpdate(CarRank::C_SortCriteria_CurrentRace);
***

***Match_PlayLoop***
***
// Manage race events
declare RacePendingEvents = Race::GetPendingEvents();
foreach (Event in RacePendingEvents) {
	Race::ValidEvent(Event);

	// Waypoint
	if (Event.Type == Events::C_Type_Waypoint) {
		CarRank::ThrottleUpdate(CarRank::C_SortCriteria_CurrentRace);
		if (Event.Player != Null) {
			if (Event.IsEndRace) {
				Scores::UpdatePlayerPrevRace(Event.Player);
				Scores::UpdatePlayerBestRaceIfBetter(Event.Player);
				Scores::UpdatePlayerBestLapIfBetter(Event.Player);
				Scores::UpdatePlayerPrevRace(Event.Player);
				// TeamsCommonLib::ComputeLatestRaceScores(S_UseCustomPointsRepartition, S_CumulatePoints, S_UseAlternateRules, S_MaxPointsPerRound);
				Race::SortScores(Race::C_Sort_BestRaceTime);

				// Start the countdown if it's the first player to finish
				if (EndTime <= 0) {
					EndTime = TeamsCommonLib::GetFinishTimeout(S_FinishTimeout);
				}

				SetFinishedRace(Event.Player.Score, True);
			}
			if (Event.IsEndLap) {
				declare Better = Scores::UpdatePlayerBestLapIfBetter(Event.Player);
			}
		}
	}
}

// Manage mode events
foreach (Event in PendingEvents) {
	if (Event.HasBeenPassed || Event.HasBeenDiscarded) continue;
	Events::Invalid(Event);
}

// Server info change
if (
	Server_RoundsPerMap != S_RoundsPerMap ||
	Server_MapsPerMatch != S_MapsPerMatch
) {
	Server_RoundsPerMap = S_RoundsPerMap;
	Server_MapsPerMatch = S_MapsPerMatch;

}
***

***Match_EndRound***
***
Race::StopSkipOutroAll();
EndTime = -1;
// StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
CarRank::Update(CarRank::C_SortCriteria_CurrentRace);

if (Semver::Compare(XmlRpc::GetApiVersion(), ">=", "2.1.1")) {
	Scores::XmlRpc_SendScores(Scores::C_Section_PreEndRound, "");
}

if (Round_ForceEndRound || Round_SkipPauseRound || Round_Skipped) {
	// Do not launch the forced end round sequence after a pause
	if (!Round_SkipPauseRound) {
		ForcedEndRoundSequence();
	}
	MB_SetValidRound(False);
} else {
	Map_ValidRoundsNb += 1;

	declare Real PreviousDelta = Map_TimeDelta;

	Race::SortScores(Race::C_Sort_PrevRaceTime);
	declare CSmScore[] PrevRaceRanking = Race::GetPrevRaceRanking();

	declare Integer Team1_DNFPlayers = 0;
	declare Integer Team2_DNFPlayers = 0;

	declare Integer Team1Players = 0;
	declare Integer Team2Players = 0;

	declare Real Team1_TotalTime = 0.0;
	declare Real Team2_TotalTime = 0.0;

	declare Real FastestTime = 0.0;

	declare Boolean FastestTimeSet = False;

	foreach (Score in PrevRaceRanking) {
		if (!GetFinishedRace(Score)) {
			if (Score.TeamNum == 1) {
				Team1Players += 1;
				Team1_DNFPlayers += 1;
			} else {
				Team2Players += 1;
				Team2_DNFPlayers += 1;
			}
		} else {
			declare Real Time = Scores::GetPlayerPrevRaceTime(Score) + 0.0;
			if (!FastestTimeSet) {
				FastestTime = Time;
				FastestTimeSet = True;
			}
			if (Score.TeamNum == 1) {
				Team1Players += 1;
				Team1_TotalTime += (Scores::GetPlayerPrevRaceTime(Score) / 1000.0);
			} else {
				Team2Players += 1;
				Team2_TotalTime += (Scores::GetPlayerPrevRaceTime(Score) / 1000.0);
			}
		}
	}

	declare Integer FinishTimeout = GetFinishTimeout();

	Team1_TotalTime += Team1_DNFPlayers * (FastestTime + FinishTimeout);
	Team2_TotalTime += Team2_DNFPlayers * (FastestTime + FinishTimeout);

	if (Team1_TotalTime == 0.0) {
		Team1_TotalTime = FastestTime + FinishTimeout;
	}

	if (Team2_TotalTime == 0.0) {
		Team2_TotalTime = FastestTime + FinishTimeout;
	}

	if (Team1Players != Team2Players) {
		if (Team1Players < Team2Players) {
			Team2_TotalTime = (Team2_TotalTime / Team2Players) * Team2Players;
		} else {
			Team1_TotalTime = (Team1_TotalTime / Team1Players) * Team1Players;
		}
	}

	declare Real TotalDelta = Team1_TotalTime - Team2_TotalTime;

	declare Real RoundSwing = ML::Abs(TotalDelta);

	if (RoundSwing > S_MaxRoundDelta) {
		if (TotalDelta < 0) {
			TotalDelta = S_MaxRoundDelta * -1.0;
		} else {
			TotalDelta = S_MaxRoundDelta + 0.0;
		}
	}


	declare Real PreviousAbsoluteDelta = ML::Abs(PreviousDelta);

	declare Boolean WinnerFound = False;


	Map_TimeDelta += TotalDelta;

	if (ML::Abs(Map_TimeDelta) >= S_MaxTimeDelta && PreviousAbsoluteDelta >= S_MaxTimeDelta && TeamAhead(Map_TimeDelta) == TeamAhead(PreviousDelta)) {
		WinnerFound = True;
		if (TotalDelta < 0) {
			Team1_MapWins += 1;
		} else {
			Team2_MapWins += 1;
		}
	} else if (Map_ValidRoundsNb >= S_MaxRounds && S_MaxRounds > 0 && TotalDelta != 0.0) {
		WinnerFound = True;
		if (TotalDelta < 0) {
			Team1_MapWins += 1;
		} else {
			Team2_MapWins += 1;
		}
	}

	// Map_TimeDelta = ML::Rand(-5000, 5000) / 1000.0;

	declare netwrite Real Map_Delta for Teams[0];
	Map_Delta = Map_TimeDelta;

	declare netwrite Real MaxTimeDelta for Teams[0];
	MaxTimeDelta = S_MaxTimeDelta;

	declare netwrite Integer DeltaVersion for Teams[0];
	DeltaVersion = LatestDeltaVersion + 1;
	LatestDeltaVersion += 1;


	if (WinnerFound) {
		Scores::SetClanMatchPoints(1, Team1_MapWins);
		Scores::SetClanMatchPoints(2, Team2_MapWins);
		declare Text MaxRoundsText = S_MaxRounds ^ "";

		if (S_MaxRounds <= 0) {
			MaxRoundsText = "Unlimited";
		}
		UIModules_ScoresTable::SetFooterInfo(TL::Compose("Round " ^ (Map_ValidRoundsNb + 1) ^ " / " ^ MaxRoundsText ^ " Map " ^ Match_MapsCount ^ " / " ^ S_MapsPerMatch));
		UIModules_ScoresTable::SetInfoMessage(TL::Compose("\n\nMax Time Delta: " ^ S_MaxTimeDelta ^ "  "));
		declare netwrite Integer RedMapWins for Teams[0];
		RedMapWins = Team2_MapWins;
		declare netwrite Integer BlueMapWins for Teams[0];
		BlueMapWins = Team1_MapWins;
		MB_StopMap();
	} else {
		UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
		declare Text MaxRoundsText = S_MaxRounds ^ "";

		if (S_MaxRounds <= 0) {
			MaxRoundsText = "Unlimited";
		}
	
	
		UIModules_ScoresTable::SetFooterInfo(TL::Compose("Round " ^ (Map_ValidRoundsNb + 1) ^ " / " ^ MaxRoundsText ^ " Map " ^ Match_MapsCount ^ " / " ^ S_MapsPerMatch));
		UIModules_ScoresTable::SetInfoMessage(TL::Compose("\n\nMax Time Delta: " ^ S_MaxTimeDelta ^ "  "));
		MB_Sleep(S_ChatTime / 2 * 1000);
		UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	}
}
***

***Match_EndMap***
***

// Message::CleanAllMessages();
MB_Sleep(250);
// TM::WaitRaceAll();

declare netwrite Integer DeltaVersion for Teams[0];
declare netwrite Real Map_Delta for Teams[0];

DeltaVersion = 0;

LatestDeltaVersion = 0;

Map_Delta = 0.0;

Race::SortScores(Race::C_Sort_BestRaceTime);

declare Integer MapWinner = TeamAhead(Map_TimeDelta);

foreach(Score in Scores) {
	if (Score.TeamNum == MapWinner) {
		Scores::AddPlayerMatchPoints(Score, 1);
		break;
	} else {
		continue;
	}
}


declare Integer MinMapWins = ML::CeilingInteger(S_MapsPerMatch / 2.0);

if (Team1_MapWins >= MinMapWins || Team2_MapWins >= MinMapWins) {
	MB_StopMatch();
 

	// Ranking
	declare Integer WinningTeam = -1;
	if (Team1_MapWins > Team2_MapWins) {
		WinningTeam = 1;
	} else {
		WinningTeam = 2;
	}
	Scores::SetClanWinner(WinningTeam);

	UIModules_ScoresTable::SetScoreMode(UIModules_ScoresTable::C_Mode_BestTime);
	UIModules_ScoresTable::DisplayRoundPoints(False);
	Race::SortScores(Race::C_Sort_BestRaceTime);

// Set scores table for podium
} else {
	MB_Sleep(2500);
}

if (!MB_MapIsRunning() && MB_MatchIsRunning()) MB_SkipPodiumSequence();
***

***EndMatch***
***
Log::Log("Match Over GG", 5500);
***

***Match_BeforePodiumSequence***
***
TeamsCommonLib::BeforePodiumSequence(Scores::GetClanWinner());
***

***Match_PodiumSequence***
***
if (MB_MatchIsRunning()) {
	MB_Sleep(2000);
} else {
	ModeUtils::PushAndApplyUISequence(UIManager.UIAll, CUIConfig::EUISequence::Podium);
	MB_Sleep(S_ChatTime * 1000);
	ModeUtils::PopAndApplyUISequence(UIManager.UIAll);
}

***

***Match_AfterPodiumSequence***
***
TeamsCommonLib::AfterPodiumSequence();
***

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// MARK: Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Whether the player finished the race or not
 *
 *	@param	_Score								Player's score
 *	@param	_HasFinished					True if player finished race
 */
 Void SetFinishedRace(CSmScore _Score, Boolean _HasFinished) {
	declare Knockout_FinishedRace for _Score = False;
	Knockout_FinishedRace = _HasFinished;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Whether the player finished the race or not
 *
 *	@param	_Score								Player's score
 *	@return												True if player finished race
 */
Boolean GetFinishedRace(CSmScore _Score) {
	declare Knockout_FinishedRace for _Score = False;
	return Knockout_FinishedRace;
}

Integer GetFinishTimeout() {
	declare FinishTimeout = 0;

	if (S_FinishTimeout >= 0) {
			FinishTimeout = S_FinishTimeout * 1000;
	} else {
			FinishTimeout = 5000;
			if (Map.TMObjective_IsLapRace && Race::GetLapsNb() > 0 && Map.TMObjective_NbLaps > 0) {
					FinishTimeout += ((Map.TMObjective_AuthorTime / Map.TMObjective_NbLaps) * Race::GetLapsNb()) / 6;
			} else {
					FinishTimeout += Map.TMObjective_AuthorTime / 6;
			}
	}

	return FinishTimeout / 1000;
}

Integer TeamAhead(Real _Time) {
	if (_Time < 0.0) {
		return 1;
	} else if (Time > 0.0) {
		return 2;
	} else {
		return 0;
	}
}


Void LoadUI() {
	declare Text MLText = """
 <?xml version="1.0" encoding="utf-8" standalone="yes" ?>
 <manialink version="3" name="TugOfWar">
  <frame id="frame-global" hidden="0">
	 <frame id="frame-matchinfo" pos="-30 90" hidden="0">
	 	 <quad id="quad-borderbg" size="60 12" pos="0 0" bgcolor="ffffff" opacity="0.2"/>
	 	 <quad id="quad-border" size="64 10" pos="-2 -12" bgcolor="ffffff" opacity="0.2"/>
		 <quad id="quad-blue" size="30 20" pos="0 0" bgcolor="0000ff" opacity="0.5" hidden="0"/>
		 <quad id="quad-red" size="30 20" pos="60 -20" rot="180" bgcolor="ff0000" opacity="0.5" hidden="0" />
		 <label id="label-matchinfo-info" halign="center" valign="center" pos="30 -8" size="60 8" textsize="8" maxline="1" linespacing="1.1" textfont="GameFontExtraBold" textcolor="ffffff" text="0" />
		 <label id="label-caution" halign="center" valign="center" pos="30 -15" size="60 8" textsize="4" maxline="1" linespacing="1.1" textfont="GameFontExtraBold" textcolor="ffffff" text="CAUTION" hidden="1"/>
		 <quad id="quad-progress-bar" size="0 2" pos="30 -18" bgcolor="ffffff" opacity="1.0" hidden="0"/>

		 <quad id="quad-blue-maps-border" size="17 12" pos="-17 0" bgcolor="ffffff" opacity="0.2"/>
		 <quad id="quad-red-maps-border" size="17 12" pos="60 0" bgcolor="ffffff" opacity="0.2"/>
		 <quad id="quad-blue-maps" size="15 10" pos="-15 0" bgcolor="0000ff" opacity="0.5" hidden="0"/>
		 <quad id="quad-red-maps" size="15 10" pos="60 0" bgcolor="ff0000" opacity="0.5" hidden="0"/>
		 <label id="label-blue-maps-count" halign="center" valign="center" pos="-7.5 -5" size="15 8" textsize="8" maxline="1" linespacing="1.1" textfont="GameFontExtraBold" textcolor="ffffff" text="0"/>
		 <label id="label-red-maps-count" halign="center" valign="center" pos="67.5 -5" size="15 8" textsize="8" maxline="1" linespacing="1.1" textfont="GameFontExtraBold" textcolor="ffffff" text="0"/>


	 </frame>
 </frame>
 <script><!--
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 // MARK: Libraries
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 #Include "TextLib" as TL
 #Include "MathLib" as ML
 #Include "ColorLib" as CL
 #Include "Libs/Nadeo/CMGame/Utils/Icons.Script.txt" as Icons
 #Include "Libs/Nadeo/CMGame/Utils/Tools.Script.txt" as Tools
 #Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/WarmupHelpers_Client.Script.txt" as WarmupHelpers

 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// MARK: Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

#Const BarTravelTime 250

 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

 Real GetCompletionPercentage(Real _Delta, Real _MaxDelta) {
	if (_MaxDelta == 0) {
		return 0.0;
	}

	declare Real CompletionPercentage = (ML::Abs(_Delta) / _MaxDelta);

	if (CompletionPercentage > 1.0) {
		CompletionPercentage = 1.0;
	}

	return CompletionPercentage;
}

 Void UpdateQuads(Real _Map_Delta, Real _MaxTimeDelta) {
 	declare CMlFrame Frame <=> (Page.GetFirstChild("frame-global") as CMlFrame);
 	declare CMlQuad Quad_Red <=> (Frame.GetFirstChild("quad-red") as CMlQuad);
	declare CMlQuad Quad_Blue <=> (Frame.GetFirstChild("quad-blue") as CMlQuad);

	declare Real CompletionPercentage = GetCompletionPercentage(_Map_Delta, _MaxTimeDelta);

	declare Real BarSize = (30.0 * CompletionPercentage) + 30.0;

	AnimMgr.Flush(Quad_Red);
	AnimMgr.Flush(Quad_Blue);


	if (_Map_Delta >= 0.0) {
		AnimMgr.Add(Quad_Red, "<a size=\"" ^ BarSize ^" 20\"/>", Now, 250, CAnimManager::EAnimManagerEasing::Linear);
		AnimMgr.Add(Quad_Blue, "<a size=\"" ^ (60.0 - BarSize) ^" 20\"/>", Now, 250, CAnimManager::EAnimManagerEasing::Linear);
	} else {
		AnimMgr.Add(Quad_Blue, "<a size=\"" ^ BarSize ^" 20\"/>", Now, 250, CAnimManager::EAnimManagerEasing::Linear);
		AnimMgr.Add(Quad_Red, "<a size=\"" ^ (60.0 - BarSize) ^" 20\"/>", Now, 250, CAnimManager::EAnimManagerEasing::Linear);
	}
  }

 Void UpdateProgressBar(Real _PrevValue, Real _Map_Delta, Real _MaxTimeDelta) {
 	declare CMlFrame Frame <=> (Page.GetFirstChild("frame-global") as CMlFrame);
 	declare CMlQuad Quad_ProgressBar <=> (Frame.GetFirstChild("quad-progress-bar") as CMlQuad);

	declare Real LocalMapDelta = _Map_Delta * -1.0;

	declare Real LocalPrevValue = _PrevValue *-1.0;

	declare Real CompletionPercentage = GetCompletionPercentage(LocalMapDelta, _MaxTimeDelta);

	declare Real BarSize = 30.0 * CompletionPercentage;

	declare Real TravelDistance = BarSize;

	if (LocalMapDelta < 0.0 && LocalPrevValue >= 0.0 || LocalMapDelta >= 0.0 && LocalPrevValue < 0.0) {
		declare Real AbsPrevValue = ML::Abs(LocalPrevValue);

		declare Real PrevCompletionPercentage = GetCompletionPercentage(LocalPrevValue * -1, _MaxTimeDelta);

		TravelDistance += 30.0 * PrevCompletionPercentage;
	}

	declare Integer Phase2TravelTime = BarTravelTime;

	if (TravelDistance > BarSize) {
	
		Phase2TravelTime = ML::NearestInteger((BarSize / TravelDistance) * BarTravelTime);
	
	}

	AnimMgr.Flush(Quad_ProgressBar);
	if (LocalMapDelta < 0.0) {

		if (LocalPrevValue >= 0.0) {
			AnimMgr.Add(Quad_ProgressBar, "<a size=\"0 2\"/>", Now, BarTravelTime - Phase2TravelTime, CAnimManager::EAnimManagerEasing::Linear);
			AnimMgr.AddChain(Quad_ProgressBar, "<a rot=\"180\" pos=\"30 -20\"/>", 1, CAnimManager::EAnimManagerEasing::Linear);
		}
		AnimMgr.AddChain(Quad_ProgressBar, "<a size=\"" ^ BarSize ^ " 2\"/>", Phase2TravelTime, CAnimManager::EAnimManagerEasing::Linear);

	} else {
		
		if (LocalPrevValue < 0.0) {
			AnimMgr.Add(Quad_ProgressBar, "<a size=\"0 2\"/>", Now, BarTravelTime - Phase2TravelTime, CAnimManager::EAnimManagerEasing::Linear);
			AnimMgr.AddChain(Quad_ProgressBar, "<a rot=\"0\" pos=\"30 -18\"/>", 1, CAnimManager::EAnimManagerEasing::Linear);
		}
	
		if (LocalMapDelta == 0.0) {

			AnimMgr.AddChain(Quad_ProgressBar, "<a size=\"0 2\"/>", Phase2TravelTime, CAnimManager::EAnimManagerEasing::Linear);

		} else {

			AnimMgr.AddChain(Quad_ProgressBar, "<a size=\"" ^ BarSize ^ " 2\"/>", Phase2TravelTime, CAnimManager::EAnimManagerEasing::Linear);

		}
	}
 }
 

Void UpdateLabel(Real _Map_Delta) {
	declare CMlFrame Frame <=> (Page.GetFirstChild("frame-global") as CMlFrame);
	declare CMlLabel Label_Info <=> (Frame.GetFirstChild("label-matchinfo-info") as CMlLabel);
	if (WarmupHelpers::IsWarmupActive(Teams[0])) {
		Label_Info.TextColor = CL::HexToRgb("FFA500");
		Label_Info.Value = "Warmup";

	} else {
		Label_Info.TextColor = CL::HexToRgb("FFFFFF");
		declare Real AbsMapDelta = ML::Abs(_Map_Delta);

		Label_Info.Value = "" ^ (ML::ToReal(ML::NearestInteger(AbsMapDelta * 1000)) / 1000.0);
	}
}

Void UpdateCautionLabel(Real _Map_Delta, Real _MaxTimeDelta) {
	declare CMlFrame Frame <=> (Page.GetFirstChild("frame-global") as CMlFrame);
	declare CMlLabel Label_Caution <=> (Frame.GetFirstChild("label-caution") as CMlLabel);
	
	declare Real CompletionPercentage = GetCompletionPercentage(_Map_Delta, _MaxTimeDelta);

	if (CompletionPercentage == 1.0) {
		Label_Caution.Visible = True;
	} else {
		Label_Caution.Visible = False;
	}
}

Void UpdateMapWinsCounters(Integer _BlueMapWins, Integer _RedMapWins) {
	declare CMlFrame Frame <=> (Page.GetFirstChild("frame-global") as CMlFrame);
	declare CMlLabel Label_Blue <=> (Frame.GetFirstChild("label-blue-maps-count") as CMlLabel);
	declare CMlLabel Label_Red <=> (Frame.GetFirstChild("label-red-maps-count") as CMlLabel);

	Label_Blue.Value = _BlueMapWins ^ "";
	Label_Red.Value = _RedMapWins ^ "";
}

main() {

	declare Integer LatestDeltaVersion = 0;

	declare Integer _RedMapWins = 0;

	declare Integer _BlueMapWins = 0;

	declare Real PrevValue = 0.0;

	while (True) {
		yield;
		declare netread Integer DeltaVersion for Teams[0] = 0;
		if (LatestDeltaVersion != DeltaVersion || DeltaVersion == 0) {
			declare netread Real Map_Delta for Teams[0] = 0.0;
			declare netread Real MaxTimeDelta for Teams[0] = 0.0;
			UpdateLabel(Map_Delta);
			UpdateCautionLabel(Map_Delta, MaxTimeDelta);
			UpdateProgressBar(PrevValue, Map_Delta, MaxTimeDelta);
			UpdateQuads(Map_Delta, MaxTimeDelta);
			LatestDeltaVersion = DeltaVersion;
			PrevValue = Map_Delta;
		}

		declare netread Integer RedMapWins for Teams[0] = 0;
		declare netread Integer BlueMapWins for Teams[0] = 0;
		
		if (_RedMapWins != RedMapWins || _BlueMapWins != BlueMapWins) {
			UpdateMapWinsCounters(BlueMapWins, RedMapWins);
			_RedMapWins = RedMapWins;
			_BlueMapWins = BlueMapWins;
		}
	}
	
}

--></script>
 </manialink>
""";
	Layers::Create(C_MlId_LiveRanking, MLText);
	Layers::SetType(C_MlId_LiveRanking, CUILayer::EUILayerType::Normal);
	Layers::Attach(C_MlId_LiveRanking);
}